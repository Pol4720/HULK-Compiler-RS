// //!
// # parser.lalrpop

// Este archivo define la gramática principal del lenguaje Hulk usando LALRPOP para el compilador Hulk.

// ## Propósito

// - Especifica la sintaxis del lenguaje Hulk, incluyendo declaraciones, expresiones, tipos, funciones, bloques, operadores y estructuras de control.
// - Traduce el código fuente en un AST (Árbol de Sintaxis Abstracta) usando las estructuras definidas en los módulos de nodos del compilador.
// - Permite la integración directa con el sistema de tipos, el análisis semántico y la generación de código.

// ## Características principales

// - **Programa principal:** Regla `Program` que representa la raíz del AST, compuesta por una lista de instrucciones.
// - **Instrucciones:** Soporte para definiciones de tipos (`type`), funciones (`function`), y expresiones.
// - **Definición de tipos:** Permite herencia, atributos y métodos dentro de bloques de tipo.
// - **Funciones:** Soporta funciones con cuerpo de bloque o de expresión, parámetros tipados y firmas.
// - **Expresiones:** Incluye expresiones aritméticas, lógicas, de comparación, llamadas a función, acceso a miembros, instanciación de tipos, bloques, literales, y control de flujo (`if`, `let-in`, `while`, `for`).
// - **Operadores:** Define precedencia y reglas para operadores binarios y unarios, incluyendo operadores personalizados como `@` para concatenación y `:=` para asignación destructiva.
// - **Bloques y listas:** Soporta bloques de código y listas de expresiones o asignaciones.
// - **Tokens y literales:** Define cómo se reconocen identificadores, literales numéricos, booleanos y de cadena, así como todos los delimitadores y palabras clave del lenguaje.

// ## Ejemplo de uso

// Un fragmento de código Hulk como:

// ```hulk
// type Point(x: Number, y: Number) {
//     name := "origin";
//     move(dx: Number, dy: Number) => {
//         x := x + dx;
//         y := y + dy;
//     }
// };

// let p = new Point(0, 0) in p.move(1, 2);
// ````

use std::str::FromStr;
use either::Either;

use crate::hulk_ast_nodes::{
    hulk_literal::*, hulk_identifier::*, hulk_binary_expr::*, hulk_unary_expr::*,
    hulk_assignment::*, hulk_whileloop::*, hulk_let_in::*, hulk_for_expr::*,
};
use crate::hulk_tokens::{
    hulk_operators::*, hulk_keywords::KeywordToken, token_pos::*,
};
use crate::hulk_ast_nodes::hulk_program::{ProgramNode, Definition};
use crate::hulk_ast_nodes::hulk_function_def::FunctionDef;
use crate::hulk_ast_nodes::hulk_function_call::FunctionCall;
use crate::hulk_ast_nodes::hulk_code_block::ExpressionList;
use crate::hulk_ast_nodes::hulk_expression::{Expr, ExprKind};
use crate::hulk_ast_nodes::hulk_if_exp::{IfExpr, ElseBranch, ElseOrElif, ElifBranch};
use crate::hulk_ast_nodes::hulk_function_def::{FunctionParams, FunctionHeaderStruct, FunctionBody, ArrowExpression};
use crate::hulk_ast_nodes::DestructiveAssignment;
use crate::hulk_ast_nodes::hulk_code_block::Block;
use crate::hulk_ast_nodes::hulk_type_def::{HulkTypeNode, AttributeDef};
use crate::hulk_ast_nodes::hulk_inheritance::Inheritance;
use crate::hulk_ast_nodes::hulk_function_access::FunctionAccess;
use crate::hulk_ast_nodes::hulk_member_access::MemberAccess;
use crate::hulk_ast_nodes::hulk_new_instance::NewTypeInstance;
use crate::hulk_ast_nodes::hulk_print_expr::PrintExpr;
use crate::semantic_visitor::hulk_semantic_visitor::*;
use crate::semantic_visitor::hulk_semantic_visitor::{Instruction, program_from_instructions};
use crate::hulk_ast_nodes::hulk_global_function::GlobalFunctionDef;

grammar;


// ===================
// Programa principal
// ===================

pub Program: ProgramNode = {
    InstructionList => program_from_instructions(<>),
}

InstructionList: Vec<Instruction> = {
    <mut h:InstructionList> <i:Instruction> => { h.push(i); h },
    <i:Instruction> => { let mut h = Vec::new(); h.push(i); h }
}

Instruction: Instruction = {
    Definition => Instruction::from(<>),
    <x:Expr> ";" => Instruction::from(*x),
}

Definition: Definition = {
    TypeDef => Definition::from(<>),
    GlobalFunctionDef => Definition::from(<>),
}

GlobalFunctionDef: GlobalFunctionDef = {
    <func_keyword:Function> <header:FunctionHeader> <body:FunctionBody> =>
        GlobalFunctionDef::from_header_and_body(func_keyword, header, body),
}

FunctionBody: FunctionBody = {
    <body:ArrowExpression> ";" => FunctionBody::from(body),
    <block:CodeBlock> => FunctionBody::from(block),
}

FunctionHeader: FunctionHeaderStruct = {
    <name:Identifier> LParen <params:IdentifierList> RParen DoubleDot <signature:Signature> =>
        FunctionHeaderStruct { name, params, signature },
    <name:Identifier> LParen RParen DoubleDot <signature:Signature> =>
        FunctionHeaderStruct { name, params: vec![], signature }
}

ArrowExpression: ArrowExpression = {
    Arrow <x:Expr> => ArrowExpression::new(x),
}

TypeDef: HulkTypeNode = {
    Type <name:Identifier> <p:Params?> <i:Inheritance?> LBrace <attrs_methods:TypeBodyDef> RBrace => {
        let (attrs, methods) = attrs_methods;
        let (parent, parent_args) = if let Some(inh) = i {
            (Some(inh.parent_type.clone()), inh.arguments)
        } else {
            (None, Vec::new())
        };
        let mut node = HulkTypeNode::new(name, parent, parent_args, p.unwrap_or_default());
        for attr in attrs { node.attributes.insert(attr.name.id.clone(), attr); }
        for method in methods { node.methods.insert(method.name.clone(), method); }
        node
    }
}

TypeBodyDef: (Vec<AttributeDef>, Vec<FunctionDef>) = {
    <members:(TypeMember Semicolon)*> => {
        let mut attrs = Vec::new();
        let mut methods = Vec::new();
        for (m, _) in members {
            match m {
                Either::Left(attr) => attrs.push(attr),
                Either::Right(method) => methods.push(method),
            }
        }
        (attrs, methods)
    }
}

TypeMember: Either<AttributeDef, FunctionDef> = {
    TypeMemberAssignment => Either::Left(<>),
    TypeMemberFunctionDef => Either::Right(<>),
}

TypeMemberAssignment: AttributeDef = {
    <id:Identifier> Assign <e:Expr> => AttributeDef { name: Identifier { id, _type: None }, init_expr: e },
}

TypeMemberFunctionDef: FunctionDef = {
    <i:Identifier> LParen <params:IdentifierList> RParen DoubleDot <s:Signature> Arrow <body:Expr> =>
        FunctionDef::new_expr(i, params, s, body),
    <i:Identifier> LParen RParen DoubleDot <s:Signature> Arrow <body:Expr> =>
        FunctionDef::new_expr(i, Vec::new(), s, body),
    <i:Identifier> LParen <params:IdentifierList> RParen DoubleDot <s:Signature> <body:CodeBlock> =>
        FunctionDef::new_expr(i, params, s, body),
    <i:Identifier> LParen RParen DoubleDot <s:Signature> <body:CodeBlock> =>
        FunctionDef::new_expr(i, Vec::new(), s, body),
}

Inheritance: Inheritance = {
    Inherits <parent_type:Identifier> LParen <p:ArgList> RParen =>
        Inheritance::new(parent_type, p.into_iter().map(|b| *b).collect()),
    Inherits <parent_type:Identifier> =>
        Inheritance::new(parent_type, Vec::new()),
}

TypeFunctionAccess: FunctionAccess = {
    <object:PrimaryExpr> DotAccess <name:Identifier> LParen <args:ArgList> RParen => FunctionAccess {
        object,
        member: Box::new(FunctionCall::new(name, args.into_iter().map(|b| *b).collect())),
        _type: None,
    }
}

TypePropAccess: Box<MemberAccess> = {
    <object:PrimaryExpr> DotAccess <name:Identifier> => Box::new(MemberAccess {
        object,
        member: Identifier { id: name, _type: None },
        _type: None,
    })
}

// ===================
// Expresiones y listas
// ===================
Expr: Box<Expr> = {
    DestructiveAssignExpr,
    LogicalOrExpr,
}

Exprs_List: ExpressionList = {
    <v:(<Expr> Semicolon)*> <last:Expr?> => {
        let mut vec = v;
        if let Some(e) = last { vec.push(e); }
        ExpressionList::new(vec.into_iter().map(|b| *b).collect())
    }
}

LogicalOrExpr: Box<Expr> = {
    <left:LogicalOrExpr> <op:LogicalOrOp> <right:LogicalAndExpr> => Box::new(Expr::new(ExprKind::BinaryOp(BinaryExpr {
        left, operator: op, right, _type: None,
    }))),
    LogicalAndExpr,
}

LogicalAndExpr: Box<Expr> = {
    <left:LogicalAndExpr> <op:LogicalAndOp> <right:EqualEqualExpr> => Box::new(Expr::new(ExprKind::BinaryOp(BinaryExpr {
        left, operator: op, right, _type: None,
    }))),
    EqualEqualExpr,
}

DestructiveAssignExpr: Box<Expr> = {
    <id:PrimaryExpr> DestructiveAssignOp <e:Expr> => Box::new(Expr::new(ExprKind::DestructiveAssign(DestructiveAssignment {
        identifier: id, expression: e, _type: None,
    }))),
}

Assignment: Assignment = {
    <id:Identifier> Assign <e:Expr> => Assignment {
        identifier: Identifier { id, _type: None },
        expression: e,
        _type: None,
    },
}

// ===================
// Operadores binarios
// ===================
EqualEqualExpr: Box<Expr> = {
    <left:ComparisonExpr> <rest:(EqualOp ComparisonExpr)*> => {
        rest.into_iter().fold(left, |left, (op, right)| {
            Box::new(Expr::new(ExprKind::BinaryOp(BinaryExpr { left, operator: op, right, _type: None })))
        })
    }
}

ComparisonExpr: Box<Expr> = {
    <left:TermExpr> <rest:(ComparisonOp TermExpr)*> => {
        rest.into_iter().fold(left, |left, (op, right)| {
            Box::new(Expr::new(ExprKind::BinaryOp(BinaryExpr { left, operator: op, right, _type: None })))
        })
    }
}

TermExpr: Box<Expr> = {
    <left:FactorExpr> <rest:(TermOp FactorExpr)*> => {
        rest.into_iter().fold(left, |left, (op, right)| {
            Box::new(Expr::new(ExprKind::BinaryOp(BinaryExpr { left, operator: op, right, _type: None })))
        })
    }
}

FactorExpr: Box<Expr> = {
    <left:ExponentExpr> <rest:(FactorOp ExponentExpr)*> => {
        rest.into_iter().fold(left, |left, (op, right)| {
            Box::new(Expr::new(ExprKind::BinaryOp(BinaryExpr { left, operator: op, right, _type: None })))
        })
    }
}

ExponentExpr: Box<Expr> = {
    <left:UnaryExpr> <op:PowOp> <right:ExponentExpr> =>
        Box::new(Expr::new(ExprKind::BinaryOp(BinaryExpr { left, operator: op, right, _type: None }))),
    UnaryExpr,
}

// ===================
// Operadores y tokens
// ===================
EqualOp: BinaryOperatorToken = {
    "==" => BinaryOperatorToken::Eq,
    "!=" => BinaryOperatorToken::Neq,
}

ComparisonOp: BinaryOperatorToken = {
    ">" => BinaryOperatorToken::Gt,
    ">=" => BinaryOperatorToken::Gte,
    "<" => BinaryOperatorToken::Lt,
    "<=" => BinaryOperatorToken::Lte,
}

TermOp: BinaryOperatorToken = {
    "+" => BinaryOperatorToken::Plus,
    "-" => BinaryOperatorToken::Minus,
    "@" => BinaryOperatorToken::Concat,
}

FactorOp: BinaryOperatorToken = {
    "*" => BinaryOperatorToken::Mul,
    "/" => BinaryOperatorToken::Div,
    "%" => BinaryOperatorToken::Mod,
}

PowOp: BinaryOperatorToken = {
    "^" => BinaryOperatorToken::Pow,
}

Assign: BinaryOperatorToken = {
    "=" => BinaryOperatorToken::Eq,
}

// ===================
// Expresiones unarias y primarias
// ===================
UnaryExpr: Box<Expr> = {
    <op:UnaryOp> <expr:UnaryExpr> => Box::new(Expr::new(ExprKind::UnaryOp(UnaryExpr { operator: op, operand: expr, _type: None }))),
    UpperExpressions,
}

UnaryOp: UnaryOperator = {
    "!" => UnaryOperator::LogicalNot,
    "-" => UnaryOperator::Minus,
    "+" => UnaryOperator::Plus,
}

FunctionCall: FunctionCall = {
    <name:Identifier> LParen <args:ArgList> RParen => FunctionCall {
        funct_name: name,
        arguments: args.into_iter().map(|b| *b).collect(),
        _type: None,
    },
}

PrintExp: Box<Expr> = {
    Print LParen <expression:Expr> RParen => Box::new(Expr::new(ExprKind::Print(PrintExpr {
        expr: expression,
        _type: None,
    }))),
}

UpperExpressions: Box<Expr> = {
    WhileLoop,
    ForExpr,
    IfExpr,
    LetIn,
    PrimaryExpr,
}

PrimaryExpr: Box<Expr> = {
    PrintExp,
    FunctionCall => Box::new(Expr::new(ExprKind::FunctionCall(<>))),
    TypeFunctionAccess => Box::new(Expr::new(ExprKind::FunctionAccess(<>))),
    TypePropAccess => Box::new(Expr::new(ExprKind::MemberAccess(*<>))),
    New <name:Identifier> LParen <args:ArgList> RParen => Box::new(Expr::new(ExprKind::NewTypeInstance(NewTypeInstance {
        type_name: Identifier { id: name, _type: None },
        arguments: args.into_iter().map(|b| *b).collect(),
        _type: None,
    }))),
    CodeBlock,
    LParen <Expr> RParen => Box::new(*<>),
    NumberLiteral => Box::new(Expr::new(ExprKind::Number(NumberLiteral { value: <>, _type: None }))),
    BooleanLiteral => Box::new(Expr::new(ExprKind::Boolean(BooleanLiteral { value: <>, _type: None }))),
    StringLiteral => Box::new(Expr::new(ExprKind::String(StringLiteral { value: <>, _type: None }))),
    Identifier => Box::new(Expr::new(ExprKind::Identifier(Identifier { id: <>, _type: None }))),
}

// ===================
// Funciones y listas de parámetros
// ===================
Function: KeywordToken = { "function" => KeywordToken::Function, }
Arrow: DelimiterToken = { "=>" => DelimiterToken::Arrow, }
Type: KeywordToken = { "type" => KeywordToken::Type, }
Inherits: KeywordToken = { "inherits" => KeywordToken::Inherits, }

IdentifierList: Vec<FunctionParams> = {
    <first:Identifier> DoubleDot <s:Signature> <rest:(Comma Identifier DoubleDot Signature)*> => {
        let mut vec = vec![FunctionParams::new(first, s)];
        for (_, id, _, signature) in rest {
            vec.push(FunctionParams::new(id, signature));
        }
        vec
    }
}

// ===================
// Bloques y listas de asignación
// ===================

CodeBlock: Box<Expr> = {
    LBrace <body:Exprs_List> RBrace => Box::new(Expr::new(ExprKind::CodeBlock(Block::new(body)))),
}

AssignmentList: Vec<Assignment> = {
    <l:AssignmentList> "," <r:Assignment> => {
        let mut l = l;
        l.push(r);
        l
    },
    <r:Assignment> => {
        let mut v = Vec::new();
        v.push(r);
        v
    },
}

// ===================
// Expresiones especiales: if, let, while, print
// ===================
LetIn: Box<Expr> = {
    <let_keyword:Let> <a:AssignmentList> <in_keyword:In> <body:UpperExpressions> => Box::new(Expr::new(ExprKind::LetIn(LetIn {
        let_token: let_keyword,
        assignment: a,
        in_keyword,
        body,
        _type: None,
    }))),
}

IfExpr: Box<Expr> = {
    <if_keyword:IfKeyword> LParen <condition:Expr> RParen <then_branch:CodeBlock> <elif_else:ElifElseChain?> => {
        Box::new(Expr::new(ExprKind::If(IfExpr::new(
            if_keyword,
            condition,
            then_branch,
            elif_else,
        ))))
    }
}

ElifElseChain: ElseOrElif = {
    <elif_branch:ElifBranch> => ElseOrElif::Elif(elif_branch),
    <else_branch:ElseBranch> => ElseOrElif::Else(else_branch),
}

ElifBranch: ElifBranch = {
    <elif_keyword:Elif> LParen <condition:Expr> RParen <then_branch:CodeBlock> <next:ElifElseChain?> => {
        ElifBranch::new(
            elif_keyword,
            condition,
            then_branch,
            next.map(Box::new),
        )
    }
}

ElseBranch: ElseBranch = {
    <elseKeyword:ElseKeyword> <body:CodeBlock> => ElseBranch::new(elseKeyword, body),
}

WhileLoop: Box<Expr> = {
    While LParen <condition:Expr> RParen <body:CodeBlock> => Box::new(Expr::new(ExprKind::WhileLoop(WhileLoop {
        condition,
        body,
        _type: None,
    }))),
}

ForExpr: Box<Expr> = {
    For LParen <id:Identifier> In <call:UpperExpressions> RParen <body:UpperExpressions> => {
        if let ExprKind::FunctionCall(ref func_call) = (*call).kind {
            if func_call.funct_name == "range" && func_call.arguments.len() == 2 {
                let mut args = func_call.arguments.clone();
                let start = args.remove(0);
                let end = args.remove(0);
                Box::new(Expr::new(ExprKind::ForExp(ForExpr {
                    variable: id,
                    start: Box::new(start),
                    end: Box::new(end),
                    body: body,
                    _type: None,
                })))
            } else {
                panic!("For loop must use `range` with exactly two arguments");
            }
        } else {
            panic!("For loop iterable must be a `range` function call");
        }
    }
}

// ===================
// Argumentos de función
// ===================
ArgList: Vec<Box<Expr>> = {
    <first:Expr> <rest:(<Comma> <Expr>)*> => {
        let mut args = vec![first];
        for (_, expr) in rest { args.push(expr); }
        args
    },
    => Vec::new(),
}

Params: Vec<FunctionParams> = {
    LParen <params:IdentifierList> RParen => params,
    LParen RParen => Vec::new(),
}

// ===================
// Tokens y literales
// ===================
Semicolon: DelimiterToken = { ";" => DelimiterToken::Semicolon }
RParen: DelimiterToken = { ")" => DelimiterToken::Rparen }
LParen: DelimiterToken = { "(" => DelimiterToken::Lparen }
RBrace: DelimiterToken = { "}" => DelimiterToken::Rbrace }
LBrace: DelimiterToken = { "{" => DelimiterToken::Lbrace }
Comma: DelimiterToken = { "," => DelimiterToken::Comma }
DoubleDot: DelimiterToken = { ":" => DelimiterToken::Doubledot }
DotAccess: DelimiterToken = { "." => DelimiterToken::DotAccess }

LogicalAndOp: BinaryOperatorToken = { "&" => BinaryOperatorToken::And }
LogicalOrOp: BinaryOperatorToken = { "|" => BinaryOperatorToken::Or }

Let: KeywordToken = { "let" => KeywordToken::Let }
Elif: KeywordToken = { "elif" => KeywordToken::Elif }
In: KeywordToken = { "in" => KeywordToken::In }
While: KeywordToken = { "while" => KeywordToken::While }
For: KeywordToken = { "for" => KeywordToken::For }
Print: KeywordToken = { "print" => KeywordToken::Print }
New: KeywordToken = { "new" => KeywordToken::New }

IfKeyword: KeywordToken = { "if" => KeywordToken::If }
ElseKeyword: KeywordToken = { "else" => KeywordToken::Else }

DestructiveAssignOp: BinaryOperatorToken = { ":=" => BinaryOperatorToken::DotEqual }

Identifier: String = {
    r"[A-Za-z][A-Za-z_0-9]*" => String::from_str(<>).unwrap(),
}

NumberLiteral: f64 = {
    r"[0-9]+(\.[0-9]+)?" => f64::from_str(<>).unwrap(),
}

BooleanLiteral: bool = {
    "true" => true,
    "false" => false,
}

StringLiteral: String = {
    r#""([^"\\]|\\.)*""# => String::from_str(&<>[1..<>.len()-1]).unwrap(),
}

Signature: String = {
    r"[A-Za-z][A-Za-z_0-9]*" => String::from_str(<>).unwrap(),
}
