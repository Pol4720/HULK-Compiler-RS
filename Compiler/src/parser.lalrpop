use std::str::FromStr;

use crate::ast::Expr;
 use crate::hulk_Tokens::hulk_operators::*;
use crate::hulk_Tokens::hulk_keywords::*;

grammar;

pub Expressions_List: Vec<Box<Expr>> = {
    <v:(<Expr> Semicolon)*> => v
};

Expr: Box<Expr> = { EqualEqualExpr };

EqualEqualExpr: Box<Expr> = {
    <left:ComparisonExpr> <rest:(EqualOp ComparisonExpr)*> => {
        rest.into_iter().fold(left, |l, (op, r)| {
            Box::new(Expr::BinaryOp(l, op, r))
        })
    }
};

EqualOp: BinaryOperatorToken = {
    "==" => BinaryOperatorToken::Eq,
    "!=" => BinaryOperatorToken::Neq,
};

ComparisonExpr: Box<Expr> = {
    <left:TermExpr> <rest:(ComparisonOp TermExpr)*> => {
        rest.into_iter().fold(left, |l, (op, r)| {
            Box::new(Expr::BinaryOp(l, op, r))
        })
    }
};

ComparisonOp: BinaryOperatorToken = {
    ">" => BinaryOperatorToken::Gt,
    ">=" => BinaryOperatorToken::Gte,
    "<" => BinaryOperatorToken::Lt,
    "<=" => BinaryOperatorToken::Lte,
};

TermExpr: Box<Expr> = {
    <left:FactorExpr> <rest:(TermOp FactorExpr)*> => {
        rest.into_iter().fold(left, |l, (op, r)| {
            Box::new(Expr::BinaryOp(l, op, r))
        })
    }
};

TermOp: BinaryOperatorToken = {
    "+" => BinaryOperatorToken::Plus,
    "-" => BinaryOperatorToken::Minus,
};

FactorExpr: Box<Expr> = {
    <left:ExponentExpr> <rest:(FactorOp ExponentExpr)*> => {
        rest.into_iter().fold(left, |l, (op, r)| {
            Box::new(Expr::BinaryOp(l, op, r))
        })
    }
};

FactorOp: BinaryOperatorToken = {
    "*" => BinaryOperatorToken::Mul,
    "/" => BinaryOperatorToken::Div,
    "%" => BinaryOperatorToken::Mod,
};

ExponentExpr: Box<Expr> = {
    <left:UnaryExpr> <op:PowOp> <right:ExponentExpr> => Box::new(Expr::BinaryOp(left, op, right)),
    UnaryExpr,
};

PowOp: BinaryOperatorToken = {
    "^" => BinaryOperatorToken::Pow,
};

UnaryExpr: Box<Expr> = {
    <op:UnaryOp> <expr:UnaryExpr> => Box::new(Expr::UnaryOp(op, expr)),
    PrimaryExpr,
};

UnaryOp: UnaryOperator = {
    "!" => UnaryOperator::LogicalNot,
    "-" => UnaryOperator::Minus,
};

PrimaryExpr: Box<Expr> = {
    NumberLiteral => Box::new(Expr::NumberLiteral(<>)),
    BooleanLiteral => Box::new(Expr::BooleanLiteral(<>)),
    StringLiteral => Box::new(Expr::StringLiteral(<>)),
    Identifier => Box::new(Expr::Identifier(<>)),
    LParen <Expr> RParen => Box::new(*<>),
    PrintExpr,
};

PrintExpr: Box<Expr> = {
    Print LParen <Expr> RParen => Box::new(Expr::Print(<>)),
};

Semicolon: DelimiterToken = {
    ";" => DelimiterToken::Semicolon,
};

RParen: DelimiterToken = {
    ")" => DelimiterToken::Rparen,
};

LParen: DelimiterToken = {
    "(" => DelimiterToken::Lparen,
};

RBrace: DelimiterToken = {
    "}" => DelimiterToken::Rbrace,
};

LBrace: DelimiterToken = {
    "{" => DelimiterToken::Lbrace,
};

Let: KeywordToken = {
    "let" => KeywordToken::Let,
};

Else: KeywordToken = {
    "else" => KeywordToken::Else,
};

Elif: KeywordToken = {
    "elif" => KeywordToken::Elif,
};

In: KeywordToken = {
    "in" => KeywordToken::In,
};

If: KeywordToken = {
    "if" => KeywordToken::If,
};

While: KeywordToken = {
    "while" => KeywordToken::While,
};

Print: KeywordToken = {
    "print" => KeywordToken::Print,
};


Identifier: String = {
    r"[A-Za-z][A-Za-z_0-9]*" => String::from_str(<>).unwrap(),
};

NumberLiteral: f64 = {
    r"[0-9]+(\.[0-9]+)?" => f64::from_str(<>).unwrap(),
};

BooleanLiteral: bool = {
    "true" => true,
    "false" => false,
};

StringLiteral: String = {
    r#""([^"\\]|\\.)*""# => String::from_str(&<>[1..<>.len()-1]).unwrap(),
};